# Домены приложений

Самое время пришло поговорить про домены приложений (AppDomains). Причем если вы скажете, что эта тема достаточно элементарна и понятна чтобы позволить себе пропустить данную главу, то в её защиту скажу что тема эта кажется такой простой по одной причине: её зачем-то обходят стороной, тогда как если вглядеться поглубже, выяснится что она очень интересна и многогранна.

Начнем мы наше изучение с несколько философского вопроса: зачем вообще вводили домены приложений? Чтобы ответить на этот вопрос необходимо немного окунуться в историю: когда балом правил С++ и технология COM, а программисты только прощупывали почву чтобы изобрести что-то наподобие нашей любимой платформы. Работа приложений в те времена по большей части была построена следующим образом: если некоторое программа позволяет расширять собственный функционал, то оно должно выставить некоторые стандартизированные методы наружу: это либо банальный экспорт методов, либо экспорт объектно-ориентированного API через COM. Однако, поскольку мы в любом случае имеем дело с общей для обоих участников процесса памятью (память линейна для процесса, процессы изолированы друг от друга), то и программа и код, её расширяющий имеют общий доступ к памяти друг друга. Как следствие этого - между ними изоляции нет абсолютно никакой. А потому, правильным образом подшаманив с указателями можно легко и просто прочитать память хоста, находясь в плагине.

Это вызывает множество проблем с безопасностью: если само приложение можно сделать безопасным с точки зрения проникновения, то расширив его функционал сторонним кодом такая уверенность сходит на нет: теперь вы живете с мыслью, что пользователь в поисках взломанной версии дорогого плагина отправится скачивать его со стороннего ресурса и скачает некий вылеченный от жадности плагин к вашему приложению чтобы запустить его. Конечно же, бесплатный сыр бывает только в мышеловке: установив его и запустив приложение такой пользователь ничего не заметит, но внедрённый авторами сайта, с которого скачан плагин, код начнёт изучать ваш компьютер в поисках наживы. Или просто заснёт до лучших времён, когда такая нажива на вашем компьютере появится.

Одним из решений подобной проблемы может стать запуск плагинов в отдельных процессах: это будет идеальной изоляцией памяти хоста от его расширений на уровне железа: процессы изолируются операционной системой в паре с процессором. Однако, это накладывает определённые ограничения: скорость заметно снижается на всех этапах взаимодействия. Ведь при вызове методов API вы должны:

  - Сериализовать данные (параметры метода)
  - Осуществить передачу до получателя через кросспроцессный механизм:
    - Например, через сокет
    - Или Shared Memory
  - На другом конце - десериализовать
  - Вызвать метод
  - Сериализовать ответ
  - прокачать его через кросспроцессный механизм
  - вернуть тому, кто запросил вызов метода

Т.е. нам необходимо выполнить **очень** много действий. Однако плата хоть и велика, результат будет прекрасен: при вызове метода гарантируется полная изоляция между хостом и плагинами по памяти. Плюс ко всему поскольку протокол контролируете именно вы, вы контролируете все возможности по переполнению буферов, которые зачастую используются при взломах.

Теория звучит великолепно, если бы не одно "но": необходимы дополнительные средства автоматизации кодогенерации библиотеки для клиента и хоста по некоторому файлу с описанием интерфейса API. Иначе велик риск человеческого фактора при ручной реализации такой обёртки. Таких средств на горизонте не наблюдалось по одной простой причине: пока мы боремся за изоляцию памяти никто не мешает процессу плагина что-либо записать на жёсткий диск (например, модифицировав некий исполняемый файл, внедрив в него вредоносные инструкции) или же обратиться по сети к какому-либо сайту. Другими словами, создав изоляцию по памяти, мы поставили дверь, вокруг которой нет ни одной стены. Согласитесь, тут мы очень похожи на кошку, которая спряталась за шторой одной только головой. Что делать в такой ситуации? Оборачивать весь WinAPI своими обёртками? Это возможно: чтобы получить доступ к WinAPI вы импортируете dll библиотеки и можете переопределить точки входа в методы, заменив их на свои и возвращать ошибки, когда плагин начнёт работать с файлами, с которыми работать не должен. Звучит практично, безопасно, элегантно. Если бы не одно но: код плагина имеет доступ к собственной памяти, а его программист - умеет пользоваться отладчиком и легко сможет понять, где ему необходимо искать таблицу расположения реальных адресов методов WinAPI.

Всё это звучит как безнадёга. Однако, в данном разговоре не хватает понимания: что конкретно мы защищаем и от чего (а главное, почему?) мы защищаемся. Защитить мы пытаемся наши данные, которые могут содержать некие пароли, средства доступа к нашим финансам, личным фотоархивам и прочей конфиденциальной информации. Скрывать всегда есть что, однако скрываем мы всегда данные. От чего мы их скрываем? От неких действий. Если нет действий, значит, данные находятся в безопасности. Значит, если обзавестись средством контроля над тем, что делает (какой исполняет код) наш плагин, значит, мы получим средство обеспечения безопасности наших данных не прибегая к созданию сложной системы взаимодействия между процессами. А как достичь полного контроля? Мы же не станем анализировать реальный скомпилированный код: средств обмана анализаторов и прочих антивирусов предостаточно. Идеально - это когда мы сами осуществляем компиляцию приложения - раз. И два - когда исходный для компиляции язык не может содержать подводных камней, позволяющих компилятор обмануть. Этими задачами занимается JIT: он просто не даст скомпилировать что-либо опасное. Второе - необходимо иметь уровни доверия: ведь в конце концов само приложение *может* иметь средства сборки опасного кода. Запрещать опасные участки необходимо плагинам и прочим средствам расширения: им-то мы не доверяем. И тут мы вплотную подошли к теме нашего разговора: JIT и домены приложений.

Поскольку наш код и код, которому мы по каким-то причинам не доверяем порождается единым компилятором (JIT), который собирает приложение относительно MSIL, то компилятор этот может быть настроен таким образом, чтобы не собирать код, который будет признан опасным. Имея единственный компилятор мы получаем средство тотального контроля над кодом, который исполняется процессором. Осталось получить абстракцию, в рамках которой будут существовать некие жёсткие правила: это и есть домены приложений.

Если попытаться обобщить, то домен приложения - это изолированная область исполнения кода. Вы можете настроить любые правила исполнения: от доступа к рефлексии до доступа к жёсткому диску. И поскольку все базовые методы доступа к этим ресурсам находятся во владении BCL и CLR, то сторонний код, загруженный в хорошо настроенную среду не сможет выбраться из такой песочницы.

Если рассматривать домены в вопросе архитектуры системы, то в понимании иерархии компонентов может сложиться не совсем верная картина мира: что базовым элементом системы типов является сам тип, далее - находятся пространства имён, модули и сборки, которые их объединяют. И венцом иерархии является домен приложения. А на самом деле всё совсем не так. Видимая иерархия является переплетением различных слоёв фреймворка .NET: если типы и пространства имён образуют систему типов и кода (мысленно расположим их по центру), то модули (слева) - средство их объединения в единую группу **в вопросе хранения**. Они не оказывают никакого влияния с точки зрения смыслового объединения. Сборка при этом - также средство хранения и объединяет модули в единый файл. Домен же занимает совершенно обособленную позицию: справа. Ведь это ни средство хранения ни средство логического разделения: это средство исполнения кода, в него загруженного.
